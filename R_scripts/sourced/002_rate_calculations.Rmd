---
title: "SET Rate Calculations"
date: "`r Sys.Date()`"
output: word_document
always_allow_html: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, error = TRUE)
```

*This document was designed for use by National Estuarine Research Reserve (NERR) technical staff and may also be useful to other Surface Elevation Table (SET) data analysts. It is meant to calculate, visualize, and describe rates of elevation change at SET stations in a given area (such as an individual NERR or reserve component). These products are output from a 2018-2019 NERRS Science Collaborative Catalyst Grant project nicknamed "SETr". For information on options to customize this report, see the document "Guide to the SETr Workflow" in the main folder of SETr outputs.* 

```{r}
# generate file list
path <- here::here('data', 'processed')
filelist <- dir(path, pattern = "set_processed.csv$")
```


# Background on the data  

This analysis was run on **`r filelist[1]`** on *`r Sys.Date()`*. 

In this report, the user may have chosen to exclude data associated with certain QA/QC codes. Any values that have been removed are listed in the appropriate section below.  

```{r load-libraries}
library(knitr)
library(forcats)
library(readr)
library(janitor)
library(dplyr)
library(tidyr)
library(ggplot2)
library(nlme)
library(broom)
library(here)
library(flextable)
library(officer)
library(readxl)
library(lubridate)
library(leaflet)
library(stringr)

# load functions
source(here::here('R_scripts', 'sourced', '000_functions.R'))
# load user options
source(here::here('R_scripts', 'sourced', '001_user_options.R'))
# user options script deals with qaqc codes


# if for some reason the output directory for individual SET figures 
# doesn't exist, create it
ind_set_dir <- here::here("R_output", "figures", "cumu_change_plots", "individual_sets")
if(!dir.exists(ind_set_dir)) dir.create(ind_set_dir)
rm(ind_set_dir)

# save a log file just in case
log_name <- paste0(Sys.Date(), "_002ratecalculations_logfile.txt")
writeLines(capture.output(sessionInfo()), here::here("R_output", "log_files", log_name))
```

## Data and metadata setup  

We start by reading in the long SET measurement dataset, converted from other formats by earlier SETr scripts. See the "Guide to the SETr Workflow" document for more detail on data formatting. In this step, pin heights were converted to mm if they were previously in cm.  


```{r read-data, warning = TRUE}
# find the folder with processed data
path <- here::here('data', 'processed')


# in that folder, find the name of the file(s) that ends with 'set_processed.csv'
filelist <- dir(path, pattern = "set_processed.csv$")


# generate warnings if the folder is empty; if there are multiple matching files, select the first one
if (length(filelist) == 0) stop("There are no files of the correct name/format (---set_QC.csv) in your processed data folder.")

if (length(filelist) > 1) {
  warning("There is more than one file of the correct format (---set_QC.csv) in your data folder. The first file alphabetically will be used.")
  filelist <- filelist[1]
}



# generate the full path to the file; read it in and get pin heights to mm
filename <- paste0(path, "/", filelist)
dat <- read_csv(filename, guess_max = 2000)
dat <- height_to_mm(dat)

# if there isn't a reserve column in the data,
# pull it from the file name
# this could end poorly if someone's working with a
# file that doesn't match the required naming conventions
# but there's a lot of grouping based on reserve, so it has to exist
if(!exists("reserve", dat)){
  dat$reserve <- toupper(str_extract(filename, "[:alpha:]{3}(?=set)"))
} 

# get rid of any placeholders; make sure set_id is a factor;
# make sure reserve, station, arm_position, and pin_number are character vectors
# paste year, month, and day together into "date"
dat <- dat %>%
  mutate(date = lubridate::ymd(paste(year, month, day))) %>% 
  filter(!is.na(date),
         !is.na(pin_number)) %>%
  mutate_at(c("reserve", "set_id",   
              "arm_position", "arm_qaqc_code", 
              "pin_number", "qaqc_code"),
            as.character)


# pull out dates in the dataset
start_whole <- min(dat$date)
end_whole <- max(dat$date)
```

This dataset spans the dates **`r start_whole`** to **`r end_whole`**.  

If custom start and/or end dates were specified for this analysis, the dataset is subsetted here and the chosen date range will be printed below this paragraph. These options can be changed in the file `metadata/user_defined_inputs.xlsx`, `general` tab.  

```{r trim-data}
# trim the dataset based on user-specified dates
if(!is.na(opts_long$custom_start)){
  start <- lubridate::ymd(opts_long$custom_start)
  dat <- dat %>% 
    filter(date >= start)
  print(paste0("The custom start date is ", start))
}
if(!is.na(opts_long$custom_end)){
  end <- lubridate::ymd(opts_long$custom_end)
  dat <- dat %>% 
    filter(date <= end)
  print(paste0("The custom end date is ", end))
}
```


## QA/QC codes  

In the same `user_defined_inputs` spreadsheet, certain QA/QC codes may have been specified for removal in this analysis. In the `qaqc_codes` worksheet, they were labeled with "-3", to be consistent with SWMP's water quality/weather/nutrient "reject" flagging. If such values are present, they will be printed below, then turned into NAs so they are not used in the analysis.

**Note** that the R code dealing with these flags looks for an EXACT match in the `qaqc_codes` worksheet, and matches are case-sensitive (all codes should be in all caps). If "LHE" is specified for removal, only values with "LHE" will be removed. "LHE CB" and "CRM LHE" will *not* be removed if only "LHE" is specified; combinations of codes need to be specified on their own line in the input spreadsheet. If you are using a new combination of codes, you may need to create a new row in that spreadsheet See the "Guide to the SETr Workflow" document for more information.     

```{r qc-remove}
if (excl_exist) {
  # find the rows to exclude - either arm or pin codes match
  pin_to_excl <- which(dat$qaqc_code %in% codes_to_exclude)
  arm_to_excl <- which(dat$arm_qaqc_code %in% codes_to_exclude)
  
  # make a data frame of the excluded ones and print it out
  to_excl <- c(pin_to_excl, arm_to_excl)
  excluded <- dat[to_excl, ]
  
  
  # print only if there's at least one row
  if(nrow(excluded) > 0){
    cat("The following QA/QC codes were labeled for exclusion: \n")
    cat(codes_to_exclude, sep = "\n")
    cat("\nThe data points that have been excluded are: \n \n")
    excluded %>% 
      select(set_id, date, 
             arm = arm_position, 
             arm_code = arm_qaqc_code, 
             pin_number, qaqc_code, pin_height) %>% 
      knit_print()
  } else {cat("The following QA/QC codes were labeled for exclusion. There were no data values flagged with those codes, so all data values are present in this analysis: \n"); cat(codes_to_exclude, sep = "/n")}
  
  
  # turn the heights into NAs
  dat$pin_height[to_excl] <- NA 
  
  # clean up
  # rm(list = c("excluded", "arm_to_excl", "pin_to_excl", "to_excl"))
} else {cat("No QA/QC codes were labeled for exclusion. All data values are present.")}
```


### File Matching checks  


If any mismatches in SET stations between the data and metadata files are present, they will be noted below. The user of this report will need to make any necessary changes in the data/metadata files.  


```{r read-metadata, warning = TRUE}
# Make sure a metadata file exists 

# find the folder with metadata
path <- here::here('metadata')

# in that folder, find the name of the file(s) that ends with 'setm.csv'
filelist <- dir(path, pattern = 'set_metadata.xls')

# generate warnings if the folder is empty; if there are multiple matching files, select the first one
if (length(filelist) == 0) stop("There are no files of the correct name/format (---set_metadata.xls or .xlsx) in your metadata folder.")

if (length(filelist) > 1) {
  warning("There is more than one file of the correct format (---set_metadata.xls or .xlsx) in your metadata folder. The first file alphabetically will be used.")
  filelist <- filelist[1]
}

# generate the full path to the file; read it in, clean the names, get rid of empty rows and columns
# make sure everything that needs to be a character is a character
filename <- paste0(path, "/", filelist)
mdat <- read_excel(filename) %>%
  janitor::clean_names() %>%
  janitor::remove_empty(which = "rows") %>% 
  mutate_at(c("unique_set_id", "user_friendly_set_name", "reserve"),
            as.character)
```


```{r verify-setid, warning = TRUE}
# Make sure the same SET IDs exist in both the data and metadata file: 

# first pull out set_id from both data frames
data_setid <- unique(as.character(dat$set_id))
metadata_setid <- unique(mdat$unique_set_id)

# find set_ids that are in the data, but not in the metadata
dat_not_m <- setdiff(data_setid, metadata_setid)
# find set_ids that are in the metadata, but not in the data
m_not_dat <- setdiff(metadata_setid, data_setid)

if (length(dat_not_m) > 0) {
  toprint <- paste(dat_not_m, collapse = ", ")
  warning(paste0("The following SET IDs exist in your data, but not in your metadata: ", toprint))
}

if (length(m_not_dat) > 0) {
  toprint <- paste(m_not_dat, collapse = ", ")
  warning(paste0("The following SET IDs exist in your metadata, but not in your data: ", toprint))
}

if (length(dat_not_m) + length(m_not_dat) == 0) {
  cat("SET IDs match in your data and metadata files.")
}

# go ahead and order the set_ids in dat and unique_set_id in mdat by the metadata's numerical_order, if available
# if this step is skipped, they should remain in character format
if (!anyNA(mdat$numerical_order)){
  mdat_sub <- select(mdat, unique_set_id, numerical_order) %>% 
    mutate(unique_set_id = factor(unique_set_id))
  dat <- dat %>% 
    mutate(set_id = factor(set_id)) %>% 
    left_join(., mdat_sub, by = c("set_id" = "unique_set_id")) %>% 
    mutate(set_id = fct_reorder(set_id, numerical_order)) %>% 
    select(-numerical_order)
  mdat <- mdat %>% 
    mutate(unique_set_id = factor(unique_set_id),
           unique_set_id = fct_reorder(unique_set_id, numerical_order))
  rm(mdat_sub)
}

# cleanup
rm(dat_not_m, m_not_dat, metadata_setid, data_setid, filelist, path)
```



```{r read-slr}
# Read in general sea-level rates sheet and pull out the rate that matches the reserve.

slr_file <- here::here('metadata', 'slr_rates.csv')
slr_rates <- read_csv(slr_file) %>%
  clean_names() %>%
  janitor::remove_empty(which = c("rows", "cols"))
```



```{r verify-slr, warning = TRUE}
# Pull out the information relevant to the current reserve. Assign relevant values to objects and print out the table with information about the site.

res_to_match <- unique(dat$reserve)

if (res_to_match %in% unique(slr_rates$reserve)) {
  slr_res <- slr_rates %>%
    filter(reserve == res_to_match) %>%
    select(-link)
  slr <- slr_res$slr_rate_mm_yr
  slr_ci <- slr_res$x95_percent_ci
  yr19chng <- slr_res$slr_19yr
  yr19_ci <- slr_res$ci95_19yr
} else {warning(paste("This reserve does not have an entry in the sea level rise rates file. Please check metadata/slr_rates.csv and enter a value using", res_to_match, "as the reserve code."))}
```



# Background information  


## Reserve-level characteristics  


+  The local, long-term rate of sea level change is **`r slr`** +/- **`r slr_ci`** mm/yr.  
+  This rate is reported by `r slr_res$nearest_nwlon_station`, NWLON station number `r as.character(slr_res$nwlon_station_number)` based on data from *`r slr_res$data_start`* to *`r slr_res$data_end`*.  
+  A shorter-term rate of water level change based on 19 years of data from the same NWLON station, using the same methods NOAA uses to calculate long-term sea level rise (ARIMA 1,0,0), is **`r yr19chng`** +/- **`r yr19_ci`** mm/yr. This date range is from *`r slr_res$yr19_start`* to *`r slr_res$yr19_end`*.  
+  The technical report on NOAA's calculation of long-term SLR trends, *Technical Report NOS CO-OPS 053 - Sea Level Variations of the United States 1854-2006* can be found here (accessed 2020-02-25): https://tidesandcurrents.noaa.gov/publications/Tech_rpt_53.pdf  



## SET-level characteristics  

### Setting  


```{r set-info-table}
# print the table
# what to print depends on whether lat/long are to be included

if(opts_long$coords_tech == 1){
  mdat %>% 
    select(unique_set_id, set_type, latitude_dec_deg, 
           longitude_dec_deg, co_dominant_species1) %>% 
    arrange(unique_set_id) %>% 
    setNames(c("SET_ID", "Type", "Lat", "Long", "Main_Veg")) %>% 
    flextable() %>% 
    theme_booktabs() %>% 
    autofit()
} else {
  mdat %>% 
    select(unique_set_id, set_type, co_dominant_species1) %>% 
    arrange(unique_set_id) %>% 
    setNames(c("SET_ID", "Type", "Main_Veg")) %>% 
    flextable() %>% 
    theme_booktabs() %>% 
    autofit()
}
```



### Sampling Information  

```{r sampling-info-table}
sample_info <- dat %>% 
  group_by(set_id) %>% 
  summarize(first_sampled = min(date),
            last_sampled = max(date),
            years_sampled = as.double(max(date) - min(date)) / 365.25,
            sample_events = length(unique(date))) 

sample_info %>% 
  flextable() %>% 
  theme_booktabs() %>% 
  autofit()
```




***

### Cumulative Change Snapshot  

Take a look at your overall change since the first reading - make sure the change looks generally linear, and make sure there are no big breaks in the data that could influence the outputs. Output will be generated even if it is not appropriate - **it is up to you to use discretion and make sure a linear model is appropriate for the data!**  

In the graphics below, the first (baseline) measurement for each pin was subtracted from every subsequent reading, to yield change-since-baseline at a pin level, for all dates. Then pins on an arm were averaged together for each date to yield change-since-baseline at the arm level. Finally, the arms for each date were averaged together to yield change-since-baseline for the SET as a whole. This is a slightly different approach than the rate calculations performed below but gives an almost identical point estimate for rate of change, and makes it easy to put change since baseline on a plot.    

```{r cumu-change, fig.width = opts_long$width_square, fig.height = opts_long$height_square}
dat_cumu <- calc_change_cumu(dat)

# without linear regression
plot_cumu_set(dat_cumu$set, columns = opts_long$multi_cols, smooth = FALSE)

# save it
out_name <- paste("R_output", "figures", "cumu_change_plots", "cumu_change_noLine.png", sep = "/")
out_file <- here::here(out_name)

ggsave(out_file, width = opts_long$width_square, height = opts_long$height_square, units = "in")

```

**The above graph is saved as:**   
_`r out_name`_   



```{r cumu-change-loop}
all_sets <- unique(dat_cumu$set$set_id)
out_path <- paste("R_output", "figures", "cumu_change_plots", "individual_sets", sep = "/")

for(i in seq_along(all_sets)){
  dat_tmp <- dat_cumu$set[dat_cumu$set$set_id == all_sets[i], ]
  p <- plot_cumu_set(dat_tmp, columns = 1, smooth = FALSE)
  plot_name = paste0("cumu_change_noLine_", all_sets[i], ".png")
  out_name <- paste(out_path, plot_name, sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, p, width = opts_long$width_short, height = opts_long$height_short, units = "in", scale = 0.8)
}
```


Graphs for each SET individually are not shown here but have been saved in _`r out_path`_


```{r cumu-change-line, fig.width = opts_long$width_square, fig.height = opts_long$height_square}
# with linear regression
plot_cumu_set(dat_cumu$set, columns = opts_long$multi_cols,
              pointsize = 2.5)

# save it
out_name <- paste("R_output", "figures", "cumu_change_plots", "cumu_change_withLine.png", sep = "/")
out_file <- here::here(out_name)

ggsave(out_file, width = opts_long$width_square, height = opts_long$height_square, units = "in")
```

**The above graph is saved as:**   
_`r out_name`_   


```{r cumu-change-line-loop}
out_path <- paste("R_output", "figures", "cumu_change_plots", "individual_sets", sep = "/")

for(i in seq_along(all_sets)){
  dat_tmp <- dat_cumu$set[dat_cumu$set$set_id == all_sets[i], ]
  p <- plot_cumu_set(dat_tmp, columns = 1, smooth = TRUE)
  plot_name = paste0("cumu_change_withLine_", all_sets[i], ".png")
  out_name <- paste(out_path, plot_name, sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, p, width = opts_long$width_short, height = opts_long$height_short, units = "in", scale = 0.8)
}
```


Graphs for each SET individually are not shown here but have been saved in _`r out_path`_


### Plus Sea Level Rise Line  

**This is an oversimplification of sea level rise:**  the slope is that of long-term, local SLR, calculated by NOAA COOPS at the NWLON station closest to the reserve. This line does not account for accelerating sea level rise or site-specific processes, and these graphs do not include actual water level data.  

These graphs are meant to illustrate and provide context for SET elevation change relative to long-term SLR.  



```{r cumu-plus-slr, fig.width = opts_long$width_square, fig.height = opts_long$height_square}

# put slr slope into "per-day" rather than "per-year" because that's how R thinks
# 365.25 accounts for leap years
slr_for_graph <- slr/365.25

# generate a SET-specific intercept based on the first date of sampling at that SET
# also add in slope because geom_abline doesn't work otherwise
intercepts <- dat_cumu$set %>% 
  group_by(set_id) %>% 
  summarize(min_date = as.integer(min(date))) %>% 
  mutate(intercept = 0 - (slr_for_graph*min_date),
         slope = slr_for_graph)

# add the line to the plot
p <- plot_cumu_set(dat_cumu$set, columns = opts_long$multi_cols,
                   pointsize = 2,
                   smooth = FALSE)
p +
  geom_smooth(se = FALSE, method = 'lm', 
              col = 'steelblue4') +
  geom_abline(data = intercepts,
              aes(intercept = intercept,
                  slope = slope),
              color = "red3",
              size = 1) +
  labs(subtitle = "red line has slope of long-term sea level rise; blue line has slope of SET change")


# save it
out_name <- paste("R_output", "figures", "cumu_change_plots", "cumu_change_withLineAndSLR.png", sep = "/")
out_file <- here::here(out_name)

ggsave(out_file, width = opts_long$width_square, height = opts_long$height_square, units = "in")
```

**The above graph is saved as:**   
`r out_name`   


```{r cumu-plus-slr-loop}
out_path <- paste("R_output", "figures", "cumu_change_plots", "individual_sets", sep = "/")

for(i in seq_along(all_sets)){
  dat_tmp <- dat_cumu$set[dat_cumu$set$set_id == all_sets[i], ]
  intercepts_tmp <- intercepts[intercepts$set_id == all_sets[i], ]
  
  
  p <- plot_cumu_set(dat_tmp, columns = opts_long$multi_cols,
                     pointsize = 2,
                     smooth = FALSE)
  p <- p +
    geom_smooth(se = FALSE, method = 'lm', 
                col = 'steelblue4') +
    geom_abline(data = intercepts_tmp,
                aes(intercept = intercept,
                    slope = slope),
                color = "red3",
                size = 1) +
    labs(subtitle = "red line has slope of long-term sea level rise; blue line has slope of SET change")
  
  
  plot_name = paste0("cumu_change_withLineAndSLR", all_sets[i], ".png")
  out_name <- paste(out_path, plot_name, sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, p, width = opts_long$width_short, height = opts_long$height_short, units = "in", scale = 0.8)
}
```


Graphs for each SET individually are not shown here but have been saved in _`r out_path`_


```{r cumu-plus-slr-2, fig.width = opts_long$width_square, fig.height = opts_long$height_square}
# add the line to the plot
p <- plot_cumu_set(dat_cumu$set, columns = opts_long$multi_cols,
                   smooth = FALSE,
                   pointsize = 2)
p + 
  geom_abline(data = intercepts,
              aes(intercept = intercept,
                  slope = slope),
              color = "red3",
              size = 0.8,
              alpha = 0.9) +
  labs(title = "Cumulative Change since first reading",
       subtitle = "red line has the slope of long-term sea level rise")


out_name <- paste("R_output", "figures", "cumu_change_plots", "cumu_change_withSLR.png", sep = "/")
out_file <- here::here(out_name)
ggsave(out_file, width = opts_long$width_square, height = opts_long$height_square, units = "in")
```


**The above graph is saved as:**   
`r out_name`   


```{r cumu-plus-slr-2-loop}
out_path <- paste("R_output", "figures", "cumu_change_plots", "individual_sets", sep = "/")

for(i in seq_along(all_sets)){
  dat_tmp <- dat_cumu$set[dat_cumu$set$set_id == all_sets[i], ]
  intercepts_tmp <- intercepts[intercepts$set_id == all_sets[i], ]
  
  
  p <- plot_cumu_set(dat_tmp, columns = opts_long$multi_cols,
                     pointsize = 2,
                     smooth = FALSE)
  
  p <- p + 
    geom_abline(data = intercepts_tmp,
                aes(intercept = intercept,
                    slope = slope),
                color = "red3",
                size = 0.8,
                alpha = 0.9) +
    labs(title = "Cumulative Change since first reading",
         subtitle = "red line has the slope of long-term sea level rise")
  
  plot_name = paste0("cumu_change_withSLR", all_sets[i], ".png")
  out_name <- paste(out_path, plot_name, sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, p, width = opts_long$width_short, height = opts_long$height_short, units = "in", scale = 0.8)
}
```


Graphs for each SET individually are not shown here but have been saved in _`r out_path`_



```{r cumu-lines-only, fig.width = opts_long$width_square, fig.height = opts_long$height_square}
# what if we just do it without any points; just smooths?
ggplot(dat_cumu$set, aes(x = date, y = mean_cumu)) +
  geom_line(col = 'gray70') +
  facet_wrap(~set_id, ncol = opts_long$multi_cols) +
  labs(title = 'Cumulative Change since first reading', 
       subtitle = 'light gray represents data; blue has slope of SET change; \nred has slope of long-term sea level rise',
       x = 'Date',
       y = 'Change since first reading (mm)') +
  theme_classic() +
  geom_smooth(se = FALSE, method = 'lm', 
              col = 'steelblue4',
              size = 1) +
  geom_abline(data = intercepts,
              aes(intercept = intercept,
                  slope = slope),
              color = "red3",
              size = 1)


out_name <- paste("R_output", "figures", "cumu_change_plots", "cumu_change_linesOnly.png", sep = "/")
out_file <- here::here(out_name)
ggsave(out_file, width = opts_long$width_square, height = opts_long$height_square, units = "in")
```


**The above graph is saved as:**   
`r out_name`   


```{r cumu-lines-only-loop}
out_path <- paste("R_output", "figures", "cumu_change_plots", "individual_sets", sep = "/")

for(i in seq_along(all_sets)){
  dat_tmp <- dat_cumu$set[dat_cumu$set$set_id == all_sets[i], ]
  intercepts_tmp <- intercepts[intercepts$set_id == all_sets[i], ]
  
  p <- ggplot(dat_tmp, aes(x = date, y = mean_cumu)) +
    geom_line(col = 'gray70') +
    facet_wrap(~set_id, ncol = 1) +
    labs(title = 'Cumulative Change since first reading', 
         subtitle = 'light gray represents data; blue has slope of SET change; \nred has slope of long-term sea level rise',
         x = 'Date',
         y = 'Change since first reading (mm)') +
    theme_classic() +
    geom_smooth(se = FALSE, method = 'lm', 
                col = 'steelblue4',
                size = 1) +
    geom_abline(data = intercepts_tmp,
                aes(intercept = intercept,
                    slope = slope),
                color = "red3",
                size = 1)
  
  
  plot_name = paste0("cumu_change_linesOnly", all_sets[i], ".png")
  out_name <- paste(out_path, plot_name, sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, p, width = opts_long$width_short, height = opts_long$height_short, units = "in", scale = 0.8)
  
}
```


Graphs for each SET individually are not shown here but have been saved in _`r out_path`_



## Cumulative change along the elevation gradient  

The following graph shows cumulative elevation change at all SETs in one graph panel. If NAVD88 information was present in metadata, the first reading at each SET was placed at that point on the y-axis. Otherwise, the SET cumulative change lines start at 0.  

Available elevation information varied between reserves in this project;  **this graph is meant to show changes along a relative elevation gradient only.** We have not overlaid water levels because we could not always be sure of the appropriate offset.  


```{r cumu-navd88, fig.width = opts_long$width_tall, fig.height = opts_long$height_tall}
# if either column has NO NAs, use the column. Preference goes to ground elevation, then receiver elevation. 
# then move through partial scenarios: use ground elevation or receiver elevation, or make it NA.
navd88s <- mdat %>% 
  select(set_id = unique_set_id, 
         ends_with("navd88"))%>% 
  mutate_at(vars(matches("navd88")), as.numeric) %>% 
  mutate(set_navd88 = case_when(!anyNA(surface_elevation_ground_navd88) ~
                                  surface_elevation_ground_navd88,
                                !anyNA(surface_elevation_receiver_navd88) ~
                                  surface_elevation_receiver_navd88,
                                !is.na(surface_elevation_ground_navd88) ~
                                  surface_elevation_ground_navd88,
                                !is.na(surface_elevation_receiver_navd88) ~
                                  surface_elevation_receiver_navd88,
                                TRUE ~ 0))


cumu_navd88 <- left_join(dat_cumu$set, navd88s, by = "set_id") %>% 
  mutate(mean_cumu = (mean_cumu/1000) + set_navd88,
         set_id = fct_reorder(set_id, desc(set_navd88)))

ggplot(cumu_navd88, aes(x = date, y = mean_cumu, color = set_id)) +
  geom_line(size = 1) +
  theme_minimal() +
  labs(title = "SET cumulative change",
       subtitle = "Each SET's position on the y-axis was \ndetermined by its NAVD88 elevation",
       y = "NAVD88 elevation (m)",
       color = "SET")


out_name <- paste("R_output", "figures", "cumu_change_plots", "cumu_change_NAVD88.png", sep = "/")
out_file <- here::here(out_name)

ggsave(out_file, width = opts_long$width_tall, height = opts_long$height_tall, units = "in")
```


**The above graph is saved as:**   
_`r out_name`_   




# Rate Calculations  


From this point on, **only SETs with 5 or more measurements over 4.5 or more years will be analyzed**. If you do not have any SETs that have been measured for this amount of time, you will NOT see analyses or graphs below.  


```{r find-enough-dat}
# make a backup
dat_all <- dat

to_keep <- unlist(sample_info[sample_info$years_sampled >= 4.5 & sample_info$sample_events >= 5, "set_id"])

not_enough_df <- dat[!(dat$set_id %in% to_keep), ]  # stns with not enough data
dat <- dat[dat$set_id %in% to_keep, ] # stns with enough data

enough_dat <- nrow(dat) > 0 # this will be used to determine the running of future code chunks

partial_dat <- nrow(dat) > 0 & nrow(not_enough_df) > 0  # this will join data frames back together when some sites have enough data and others don't
```

### SETs that are included in the following analyses  

```{r}
if(enough_dat){
  cat(paste(unique(dat$set_id), collapse = ", "))
} else { cat("No SETs had enough data to be included in analyses.") }
```



### SETs that are not included in analyses  

```{r}
if(nrow(not_enough_df) > 0){
  cat(paste(unique(not_enough_df$set_id), collapse = ", "))
} else { cat("All SETs were included in analyses.") }
```

***  


# Statistical methodology   

Rates of elevation change at each SET were generated using random-intercept linear mixed models. See Zuur et al. (2009) and Cahoon et al. (2019) for details.

Linear mixed models extend traditional linear regression models by allowing for the inclusion of both fixed and random effects. *These types of models are particularly useful when the data are structured hierarchically*, as with SET data. Data for each SET is analyzed separately using pin height as the response variable; arm and pin (nested in arm) are treated as random effects; and date is considered a numeric covariate. As both the intercept and slope include random effects, methods other than least squares must be employed. 


For each SET, we initially considered two LMMs, as in Cahoon et al. (2019): a LMM that includes a random intercept (with a random effects for arm and for pin nested in arm) and a LMM that includes both a random slope and a random intercept (with random effects for arm and for pin nested in arm). For many SETs, we observed that the random intercept model fit better. At other SETs, the random slope and intercept model produced better fitting models (based on AIC). However, the resulting point estimates showed only small differences between the two approaches. As the random intercept models did not require the same degree of scrutiny when model fitting, and did not cause as many script-running errors, we exclusively employed random intercept models in these automated R scripts. For more detailed analyses at a smaller level, we recommend consideration of both models.  


## General recommendations on analysis of SET data  


+  Before analysis, the analyst should carefully examine plots of the data to ensure that a linear model is appropriate. *If the points exhibit curvature or if there is some sort of a changepoint, this type of analysis may not be appropriate.* Graphs are provided in this report to help with this determination.  
+  The analyst should also look for highly influential observations. One way that this could occur is when there is a *large temporal gap* in the data.  
+  Be aware that, though we have done our best to appropriately describe uncertainty in the following rate calculations, the analyses below do not account for *temporal dependence* in the data. This could mean that confidence intervals are narrower than they should be and may be something the analyst wishes to address in future analyses.  
+  The analyst should employ a statistically valid model fitting strategy. When using Linear Mixed Models (LMMs), as we do below, this should also include addressing issues such as: 
    +  ensuring convergence of the numerical optimization  
    +  exploring sensitivity to starting values in the optimization procedure  
    +  determining whether a random slope model or a random slope/random intercept model is most appropriate, and  
    +  verifying model assumptions.  


## Statistical details of this analysis  

For this analysis, models were fit in R, using the `lme()` function in the `nlme` package (Pinheiro et al. 2019). Confidence intervals were generated using the `intervals()` function, also in the `nlme` package. 

Variable names within each SET were:  

+  **response variable:** pin_height  
+  **fixed effect:** date  
+  **random effects:** arm_position, pin_number (with pin_number nested in arm_position)  

All calculations generated output in *mm/day* and these rates were converted to *mm/yr* by multiplying by 365.25, to account for leap years. 


## Calculated rates of elevation change  

```{r calc-lmm, eval = enough_dat}
models2 <- dat %>%
  group_by(reserve, set_id) %>%
  do(mod = lme(pin_height ~ date, data = ., random = ~1|arm_position/pin_number, na.action = na.omit))

lmm_out <- models2 %>% 
  mutate(rate = intervals(mod, which = "fixed")$fixed["date", 2] * 365.25,
         CI_low = intervals(mod, which = "fixed")$fixed["date", 1] * 365.25,
         CI_high = intervals(mod, which = "fixed")$fixed["date", 3] * 365.25) %>% 
  select(-mod)

lmm_out %>% 
  flextable() %>% 
  theme_booktabs() %>% 
  autofit()
```

```{r lmm-na-table, eval = !enough_dat}
# if there wasn't enough data to run lmms, generate a data frame full of NAs
# because we need an output table to be generated to make the mapping script work
lmm_out <- dat_all %>% 
  select(reserve, set_id) %>% 
  distinct() %>% 
  mutate(rate = NA_real_,
         CI_low = NA_real_,
         CI_high = NA_real_)
```


```{r lmm-partialna-table, eval = partial_dat}
# if some sites had enough data and some didn't, add the ones that didn't
# back into the lmm_out data frame
# for the maps

# i want this included in the rate summary table
# so it shows up in maps
# but i don't want empty rows on the summary graphics

# so i'm going to add it back to the lmm_out table
# and then filter these sites out again later
lmm_out <- not_enough_df %>% 
  select(reserve, set_id) %>% 
  distinct() %>% 
  full_join(., lmm_out)
```

### Additional model diagnostics  

```{r addl-diagnostics, eval = enough_dat}
diagnostics_out <- models2 %>% 
  mutate(sigma = sigma(mod),
         AIC = AIC(mod),
         BIC = BIC(mod),
         logLik = mod$logLik) %>% 
  select(-mod)

diagnostics_out %>% 
  flextable() %>% 
  theme_booktabs() %>% 
  autofit()
```



```{r combine-rates-mdat-slr}
# combine different data frames into one file  
# no condition to run this chunk because we made up a lmm_out data frame above
# even if there hadn't been enough data to calculate rates

# pick out relevant fields from the metadata to be used for mapping
mdat_sub <- mdat %>% 
  select(unique_set_id, user_friendly_set_name, reserve, latitude_dec_deg, longitude_dec_deg, co_dominant_species1)

# join that to the rates generated by the model output above
rate_summary <- left_join(lmm_out, mdat_sub, by = c("reserve" = "reserve", "set_id" = "unique_set_id"))

# now add in slr info, and also calculate the lower and upper CI limits for SLR
rate_summary <- left_join(rate_summary, slr_rates, by = c("reserve" = "reserve")) %>% 
  rename(slr_rate = slr_rate_mm_yr) %>% 
  mutate(slr_CI_low = slr_rate - x95_percent_ci,
         slr_CI_high = slr_rate + x95_percent_ci,
         set_slr_ratio = rate / slr_rate,
         yr19_CI_low = slr_19yr - ci95_19yr,
         yr19_CI_high = slr_19yr + ci95_19yr) %>% 
  select(reserve, set_id, rate, CI_low, CI_high, slr_rate, slr_CI_low, slr_CI_high, slr_19yr, yr19_CI_low, yr19_CI_high, everything())

```




```{r slr-comp-assignment}
# removed the "eval = enough_dat" condition from this chunk
# because we need to write out a data frame for the mapping script
# and this should just label everything at the sites "nonsig" if there wasn't
# enough data to generate rates
# i no longer like that terminology; "unknown" would be better
# but i don't want to change the map script at this point
# maybe "not enough information" like i have in the pie charts

rates_slr_all <- rate_summary %>%
  mutate(dir_0 = case_when(CI_high < 0 ~ "dec_sig",
                           CI_low > 0  ~ "inc_sig",
                           rate < 0 ~ "dec_nonsig",
                           rate > 0 ~ "inc_nonsig",
                           TRUE ~ "nonsig"),
         dir_slr = case_when(CI_high < slr_CI_low ~ "dec_sig",
                             CI_low > slr_CI_high  ~ "inc_sig",
                             rate < slr_rate ~ "dec_nonsig",
                             rate > slr_rate ~ "inc_nonsig",
                             TRUE ~ "nonsig"),
         dir_19yr = case_when(CI_high < yr19_CI_low ~ "dec_sig",
                              CI_low > yr19_CI_high  ~ "inc_sig",
                              rate < slr_19yr ~ "dec_nonsig",
                              rate > slr_19yr ~ "inc_nonsig",
                              TRUE ~ "nonsig"))

```


```{r rate-summ-file}
# write that to a csv for use in mapping script
write.csv(rates_slr_all, 
          here::here("data", "intermediate", "rate_summary.csv"),
          row.names = FALSE)
```

```{r subset-for-graphics}
# subset that for making comparison tables
# select only certain columns, and get rid of rows where a rate wasn't calculated
# but the big data frame will be used in the mapping script
rates_slr_comp <- rates_slr_all %>% 
  select(reserve, set_id, rate, CI_low, CI_high, set_slr_ratio, dir_0, dir_slr, dir_19yr) %>% 
  filter(!is.na(rate))

# also filter NAs back out of lmm_out
lmm_out <- lmm_out %>% 
  filter(!is.na(rate))
```


***
***


# Comparisons to 0 and SLR  

In the following tables and graphics, rates of elevation change at each SET are compared to rates of water level change (SLR = long-term sea level rise; 19yr = water level change over a 19 year period) by investigating whether confidence intervals overlap. This method of comparison was chosen because different methods were used to calculate rates for sea level rise (ARIMA) and SET elevation change (LMMs), using data from different sources. We note that each individual interval has 95% confidence associated with it, and conclusions that are made based on pairwise comparison of these intervals will not necessarily be equivalent to conducting a formal hypothesis test for a difference at the 5% level (Schenker and Gentleman, 2001).  

For comparisons to 0, if the SET's 95% CI does not include 0, this *is* equivalent to a formal hypothesis test. For consistency, we are using the same terminology, involving overlapping CIs for all comparisons.



## Overall Summary Table  

In this table, the SETs are ordered by their rate of change, from lowest at the top to highest at the bottom. The rate and 95% CI (all in mm/yr) for each SET are provided. The last 6 columns show comparisons to: zero (is elevation at the SET changing?), long-term SLR, and 19-year water level change. Each comparison takes up two columns: a comparison of point estimates (is the SET rate higher or lower than what it is compared to), and whether or not the confidence intervals overlap.  

```{r}
rates_comp_split <- rates_slr_comp %>% 
  select(-reserve, -set_slr_ratio) %>% 
  arrange(rate) %>% 
  separate(dir_0, into = c("comp_0", "CI_over_0"), sep = "_") %>% 
  separate(dir_slr, into = c("comp_slr", "CI_over_slr"), sep = "_") %>% 
  separate(dir_19yr, into = c("comp_19yr", "CI_over_19yr"), sep = "_") %>% 
  mutate_at(
    vars(starts_with("comp")),
    list(~ case_when(
      . == "inc" ~ "higher",
      . == "dec" ~ "lower",
      TRUE ~ . ))
    ) %>% 
  mutate_at(
    vars(starts_with("CI_over")),
    list(~ case_when(
      . == "sig" ~ "no",
      . == "nonsig" ~ "yes",
      TRUE ~ . ))
  )
```

```{r}
rates_comp_table <- flextable(rates_comp_split) %>% 
  bold(part = "header", bold = TRUE) %>% 
  set_header_labels(
    set_id = "SET",
    rate = "Rate",
    CI_low = "95% CI",
    CI_high = "95% CI",
    comp_0 = "Compared to 0",
    CI_over_0 = "Compared to 0",
    comp_slr = "Compared to SLR",
    CI_over_slr = "Compared to SLR",
    comp_19yr = "Compared to 19-yr change",
    CI_over_19yr = "Compared to 19-yr change"
  ) %>% 
  merge_at(i = 1, j = 9:10, part = "header") %>% 
  merge_at(i = 1, j = 7:8, part = "header") %>% 
  merge_at(i = 1, j = 5:6, part = "header") %>% 
  merge_at(i = 1, j = 3:4, part = "header") %>% 
  fontsize(size = 9, part = "body") %>% 
  fontsize(size = 10, part = "header")

rates_comp_table <- rates_comp_table %>% 
  add_header_row(values = c("",
                            "mm/yr",
                            "lower",
                            "upper",
                            "point",
                            "CI overlap?",
                            "point",
                            "CI overlap?",
                            "point",
                            "CI overlap?"),
                 top = FALSE) %>% 
  fontsize(size = 9, part = "header", i = 2)

std_border = fp_border(color = "gray80", width = 1)
rates_comp_table <- rates_comp_table %>% 
  theme_zebra() %>% 
  border_inner_v(part = "all", border = std_border) %>% 
  border_outer(border = std_border, part = "all") %>% 
  align(align = "center", part = "all") %>%
  align(align = "left", part = "body", j = 1) %>% 
  width(width = c(1, rep(0.7, 9)))

rates_comp_table
```


# Increasing/Decreasing (Comparison to 0)  

The following tables break the SETs into groups where the rate of SET elevation change is *lower than* / *higher than* / *not different from* 0. *Lower than* and *higher than* tables imply that the 95% confidence intervals for the SET's rate of elevation change do not include 0. *Not different from* means that 0 *is* included.  


<br>

***

## SET Elevation Change < 0 mm/yr  


```{r zero-comp-lower, eval = enough_dat}
rate_comp(rates_slr_comp, dir_0, "dec_sig")
```

<br>

***

## SET Elevation Change > 0 mm/yr  


```{r zero-comp-higher, eval = enough_dat}
rate_comp(rates_slr_comp, dir_0, "inc_sig")
```

<br>

***

## SET Elevation Change 95% CI Includes 0 mm/yr  


```{r zero-comp-same, eval = enough_dat}
rate_comp(rates_slr_comp, dir_0, c("dec_nonsig", "inc_nonsig"))
```


***
***


# Sea Level Rise Comparisons  

## Period of Record (long-term SLR)  

The long-term local rate of sea level rise is **`r slr` +/- `r slr_ci` mm/yr** .  

This rate is reported by `r slr_res$nearest_nwlon_station`, NWLON station number `r as.character(slr_res$nwlon_station_number)` based on data from *`r slr_res$data_start`* to *`r slr_res$data_end`*.  

The following tables break the SETs into groups where the rate of SET elevation change is *lower than* / *higher than* / *not different from* this SLR rate. *Lower than* and *higher than* tables imply that 95% confidence intervals do not overlap between the SET and SLR. *Not different from* means that confidence intervals *do* overlap.  


This method of comparison was chosen because different methods were used to calculate rates for sea level rise (ARIMA) and SET elevation change (LMMs) using data from different sources. We note that each individual interval has 95% confidence associated with it, and conclusions that are made based on pairwise comparison of these intervals will not necessarily be equivalent to conducting a formal hypothesis test for a difference at the 5% level (Schenker and Gentleman, 2001).


<br>

<br>

***

## SET Elevation Change < SLR; CIs don't overlap  


```{r slr-comp-lower, eval = enough_dat}
rate_comp(rates_slr_comp, dir_slr, "dec_sig")
```

<br>


***

## SET Elevation Change > SLR; CIs don't overlap


```{r slr-comp-higher, eval = enough_dat}
rate_comp(rates_slr_comp, dir_slr, "inc_sig")
```

<br>

***

## SET Elevation Change and SLR CIs overlap  


```{r slr-comp-same, eval = enough_dat}
rate_comp(rates_slr_comp, dir_slr, c("dec_nonsig", "inc_nonsig"))
```


***
***


## 19-year water level change  

The local, 19-year rate of water level change is **`r yr19chng` +/- `r yr19_ci` mm/yr** .  

This rate uses data reported by `r slr_res$nearest_nwlon_station`, NWLON station number `r as.character(slr_res$nwlon_station_number)` based on data from *`r slr_res$yr19_start`* to *`r slr_res$yr19_end`*.  

The following tables break the SETs into groups where the rate of SET elevation change is *lower than* / *higher than* / *not different from* this 19-year rate. *Lower than* and *higher than* tables imply that 95% confidence intervals do not overlap between the SET and water level change. *Not different from* means that confidence intervals *do* overlap.  


This method of comparison was chosen because different methods were used to calculate rates for sea level rise (ARIMA) and SET elevation change (LMMs) using data from different sources. We note that each individual interval has 95% confidence associated with it, and conclusions that are made based on pairwise comparison of these intervals will not necessarily be equivalent to conducting a formal hypothesis test for a difference at the 5% level (Schenker and Gentleman, 2001).

<br>

<br>

***

## SET Elevation Change < 19-year water level change; CIs don't overlap  


```{r yr19-comp-lower, eval = enough_dat}
rate_comp(rates_slr_comp, dir_19yr, "dec_sig")
```

<br>


***

## SET Elevation Change > 19-year water level change; CIs don't overlap


```{r yr19-comp-higher, eval = enough_dat}
rate_comp(rates_slr_comp, dir_19yr, "inc_sig")
```

<br>

***

## SET Elevation Change and 19-year water level change CIs overlap  


```{r yr19-comp-same, eval = enough_dat}
rate_comp(rates_slr_comp, dir_19yr, c("dec_nonsig", "inc_nonsig"))
```


***
***





```{r add-veg, eval = enough_dat}
# Add dominant veg to model_out data frame for graphing purposes

lmm_out <- left_join(lmm_out, select(mdat, unique_set_id, co_dominant_species1), by = c("set_id" = "unique_set_id")) %>% 
  rename(veg = co_dominant_species1)
```


# Graphical Comparisons to Sea Level Rise and 0  

If dominant vegetation was provided in the metadata document, the following graphs will be provided both with and without points colored by vegetation type. If any vegetation entries were missing, the vegetation point-coloration will NOT be provided. You can generate them by adding vegetation to the "CoDominant Species 1" column of the `---set_metadata.xlsx` document.   

## Sites in alphabetical order, R's default  


```{r, fig.width = opts_long$width_short, fig.height = opts_long$height_short, eval = enough_dat}
# there must be a better way to do this

# function arguments are what I want to be the defaults
plot_comp_specific <- function(data = lmm_out, 
                               plot_type = 4, 
                               set_ids = set_id,
                               set_ci_low = CI_low, 
                               set_ci_high = CI_high,
                               rates = rate, 
                               comp1 = slr, 
                               comp1_ci_low = slr - slr_ci, 
                               comp1_ci_high = slr + slr_ci,
                               comp2 = yr19chng,
                               comp2_ci_low = yr19chng - yr19_ci,
                               comp2_ci_high = yr19chng + yr19_ci,
                               color_by_veg = FALSE, veg = veg){
  
  # feed all that stuff to the plot_rate_comps function
  p <- plot_rate_comps(data = {{data}}, 
                       plot_type = plot_type, 
                       set_ids = {{set_ids}},
                       set_ci_low = {{set_ci_low}}, 
                       set_ci_high = {{set_ci_high}},
                       rates = {{rates}}, 
                       comp1 = comp1, 
                       comp1_ci_low = comp1_ci_low, 
                       comp1_ci_high = comp1_ci_high,
                       comp2 = comp2,
                       comp2_ci_low = comp2_ci_low,
                       comp2_ci_high = comp2_ci_high,
                       color_by_veg = color_by_veg, veg = veg)
  p
}

```

```{r}
# set up options for the legend in the veg plots
leg_pos <- ifelse(opts_long$legend_side == 1, "right", "bottom")
leg_align <- ifelse(opts_long$legend_alignment == 1, "vertical", "horizontal")
user_leg <- theme(legend.position = leg_pos,
                  legend.direction = leg_align)

```


```{r plot-slr-ci-lmm, fig.width = opts_long$width_short, fig.height = opts_long$height_short, eval = enough_dat}

# original; only long-term SLR; all CIs included
plot_comp_specific(plot_type = 3)

out_name <- paste("R_output", "figures", "summary_plots", "summary_plot.png", sep = "/")
out_file <- here::here(out_name)

ggsave(out_file, width = opts_long$width_short, height = opts_long$height_short, scale = 0.8)

cat(paste("The above graph is saved as: ", out_name))
```



```{r plot-slr-ci-lmm-veg, fig.width = opts_long$width_veg, fig.height = opts_long$height_veg, eval = enough_dat}


if(!anyNA(lmm_out$veg)){

  # original; colored by veg
  plot_comp_specific(plot_type = 3, color_by_veg = TRUE) +
    user_leg
  
  out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_veg.png", sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, width = 1.2*opts_long$width_veg, height = opts_long$height_veg, scale = 0.8)
  
  cat(paste("The above graph is saved as: ", out_name))
  
}
```


```{r plot-slr-ci-19yr-lmm, fig.width = opts_long$width_short, fig.height = opts_long$height_short, eval = enough_dat}

# add 19-year water level change; no veg coloring
plot_comp_specific()

out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_bothSLRs.png", sep = "/")
out_file <- here::here(out_name)

ggsave(out_file, width = opts_long$width_short, height = opts_long$height_short, scale = 0.8)

cat(paste("The above graph is saved as: ", out_name))
```



```{r plot-slr-ci-lmm-veg-19yr, fig.width = opts_long$width_veg, fig.height = opts_long$height_veg, eval = enough_dat}
# 19-year water level change, with veg coloring

if(!anyNA(lmm_out$veg)){
  
  plot_comp_specific(plot_type = 4, color_by_veg = TRUE) +
    user_leg
  
  out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_veg_19yr.png", sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, width = 1.2*opts_long$width_veg, height = opts_long$height_veg, scale = 0.8)
  
  cat(paste("The above graph is saved as: ", out_name))
  
}
```


## Ordered (categorically) by NAVD88 elevation  


If NAVD88 elevations were provided in the metadata, two more versions of the graph above are produced below. The SETs are ordered along the y-axis from highest to lowest elevation.

```{r, eval = enough_dat}
# first get the factors in the right order

lmm_out_navd88order <- left_join(lmm_out, navd88s)

a <- forcats::fct_reorder(lmm_out_navd88order$set_id,
                          lmm_out_navd88order$set_navd88)

lmm_out_navd88order$set_id2 <- a

# as a condition to make the graphs:
# the navd88s can't all be "0"
# so the length of the vector with unique navd88s has to be longer than 1
multiple_navd88s <- length(unique(lmm_out_navd88order$set_navd88)) > 1
```



```{r plot-slr-ci-19yr-lmm-navd88order, fig.width = opts_long$width_short, fig.height = opts_long$height_short, eval = enough_dat}

if(multiple_navd88s){
  # add 19-year water level change; no veg coloring
  p <- plot_comp_specific(data = lmm_out_navd88order,
                          set_ids = set_id2)
  
  print(p)
  
  out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_bothSLRs_navd88ordering.png", sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, plot = p, width = opts_long$width_short, height = opts_long$height_short, scale = 0.8)
  
  cat(paste("The above graph is saved as: ", out_name))
}
```

```{r plot-slr-ci-19yr-lmm-navd88order-veg, fig.width = opts_long$width_veg, fig.height = opts_long$height_veg, eval = enough_dat}

if(multiple_navd88s){
  # add 19-year water level change; yes veg coloring
  if(!anyNA(lmm_out$veg)){
    p <- plot_comp_specific(data = lmm_out_navd88order,
                            set_ids = set_id2,
                            color_by_veg = TRUE,
                            veg = veg) +
      user_leg
    
    print(p)
    
    out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_bothSLRs_navd88ordering_veg.png", sep = "/")
    out_file <- here::here(out_name)
    
    ggsave(out_file, plot = p, width = opts_long$width_veg, height = opts_long$height_veg, scale = 0.8)
    
    cat(paste("The above graph is saved as: ", out_name))
  }
}
```

***

***

## Sites by a user-specified order  

If the `numerical_order` column of the metadata was filled out, the order of SETs in the graphics below will be in that order, as well as labeled with user-friendly names. Note that no plot will be produced if there are any NAs (missing values) in the metadata fields `numerical_order` or `user_friendly_set_name`.    

```{r plot-slr-ci-lmm-ordered, fig.width = opts_long$width_short, fig.height = opts_long$height_short, eval = enough_dat}
# only run this chunk if numerical order and user friendly names are specified for all SETs

# friendly names need more space - up width in ggsave by 10%
# veg legends need more space - up width in ggsave by 20%
# if both: 25% wider???

if(sum(is.na(mdat$numerical_order)) + sum(is.na(mdat$user_friendly_set_name)) == 0){
  
  
  # deal with data types and orders
  # make the set id a factor
  lmm_out_ordered <- mdat %>% 
    select(unique_set_id, user_friendly_set_name, numerical_order) %>%
    left_join(lmm_out, ., by = c("set_id" = "unique_set_id")) 
  
  a <- forcats::fct_reorder(lmm_out_ordered$user_friendly_set_name,
                            desc(lmm_out_ordered$numerical_order))
  b <- forcats::fct_reorder(lmm_out_ordered$set_id,
                            desc(lmm_out_ordered$numerical_order))
  
  lmm_out_ordered$user_friendly_set_name <- a
  lmm_out_ordered$set_id2 <- b
  
  
  
  
  
  # original plot
  
  p <- plot_comp_specific(plot_type = 3, 
                          data = lmm_out_ordered, 
                          set_ids = user_friendly_set_name)
  
  print(p)
  
  out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_ordered.png", sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, p, width = opts_long$width_short, height = opts_long$height_short, scale = 0.8)
  
  cat(paste("The above graph is saved as: ", out_name))
  
  
  
  
  # original, colored by veg
  if(!anyNA(lmm_out$veg)){
    p <- plot_comp_specific(plot_type = 3,
                            data = lmm_out_ordered,
                            set_ids = set_id2,
                            color_by_veg = TRUE) +
      user_leg
    
    print(p)
    
    out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_ordered_veg.png", sep = "/")
    out_file <- here::here(out_name)
    
    ggsave(out_file, p, width = 1.1*opts_long$width_veg, height = opts_long$height_veg, scale = 0.8)
    
    cat(paste("The above graph is saved as: ", out_name))
  }
  
  
  
  # original, with user-friendly name
  
  p <- plot_comp_specific(data = lmm_out_ordered,
                          plot_type = 3,
                          set_ids = user_friendly_set_name)
  
  print(p)
  
  out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_ordered_friendly_names.png", sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, p, width = opts_long$width_short, height = opts_long$height_short, scale = 0.8)
  
  cat(paste("The above graph is saved as: ", out_name))
  
  
  
  
  
  # original, with user-friendly names, and colored by veg
  if(!anyNA(lmm_out$veg)){
    p <- plot_comp_specific(data = lmm_out_ordered,
                            plot_type = 3,
                            set_ids = user_friendly_set_name,
                            color_by_veg = TRUE) +
      user_leg
    
    print(p)
    
    out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_ordered_friendly_names_veg.png", sep = "/")
    out_file <- here::here(out_name)
    # because the legend is pretty wide for the plots with veg coloring, I'm saving them 20% wider than specified. this makes the final dimensions of the main panel comparable to the non-veg plots.
    ggsave(out_file, p, width = 1.1*opts_long$width_veg, height = opts_long$height_veg, scale = 0.8)
    
    cat(paste("The above graph is saved as: ", out_name))
  }
  
  
  
  # 19-year change added
  
  p <- plot_comp_specific(plot_type = 4, 
                          data = lmm_out_ordered, 
                          set_ids = user_friendly_set_name)
  
  print(p)
  
  out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_ordered_with19yr.png", sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, p, width = opts_long$width_short, height = opts_long$height_short, scale = 0.8)
  
  cat(paste("The above graph is saved as: ", out_name))
  
  
  
  
  # original, colored by veg
  if(!anyNA(lmm_out$veg)){
    p <- plot_comp_specific(plot_type = 4,
                            data = lmm_out_ordered,
                            set_ids = set_id2,
                            color_by_veg = TRUE) +
      user_leg
    
    print(p)
    
    out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_ordered_with_19yr_veg.png", sep = "/")
    out_file <- here::here(out_name)
    
    ggsave(out_file, p, width = 1.1*opts_long$width_veg, height = opts_long$height_veg, scale = 0.8)
    
    cat(paste("The above graph is saved as: ", out_name))
  }
  
  
  
  # original, with user-friendly name
  
  p <- plot_comp_specific(data = lmm_out_ordered,
                          plot_type = 4,
                          set_ids = user_friendly_set_name)
  
  print(p)
  
  out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_ordered_friendly_names_with_19yr.png", sep = "/")
  out_file <- here::here(out_name)
  
  ggsave(out_file, p, width = opts_long$width_short, height = opts_long$height_short, scale = 0.8)
  
  cat(paste("The above graph is saved as: ", out_name))
  
  
  
  
  
  # original, with user-friendly names, and colored by veg
  if(!anyNA(lmm_out$veg)){
    p <- plot_comp_specific(data = lmm_out_ordered,
                            plot_type = 4,
                            set_ids = user_friendly_set_name,
                            color_by_veg = TRUE) +
      user_leg
    
    print(p)
    
    out_name <- paste("R_output", "figures", "summary_plots", "summary_plot_ordered_friendly_names_with19yr_veg.png", sep = "/")
    out_file <- here::here(out_name)
    # because the legend is pretty wide for the plots with veg coloring, I'm saving them 20% wider than specified. this makes the final dimensions of the main panel comparable to the non-veg plots.
    ggsave(out_file, p, width = 1.1*opts_long$width_veg, height = opts_long$height_veg, scale = 0.8)
    
    cat(paste("The above graph is saved as: ", out_name))
  }
}

```



***

# MAPS  

The way the maps are rendered below (and even *if* they are rendered) depends on several things specific to your computer. The script `R_scripts/04_interact_maps.R` will let you interact with the maps, and you can either take a screenshot or use the `Export` command from RStudio's Viewer pane to save a version that looks better. Even if no output was generated in this Word document, you should still be able to use the interactive script to generate maps.    


```{r map-script-source}
source(here::here("R_scripts", "sourced", "004_map_making_static.R"))
```


### Comparisons to 0  


```{r map0}
m0
```

### Comparisons to long-term SLR  

```{r mapSLR}
mSLR
```


### Comparisons to 19-yr water level change  

```{r map19yr}
m19yr
```



# References  


Cahoon, D.R., J.C. Lynch, C.T. Roman, J.P. Schmit, and D.E. Skidds. 2019. Evaluating the Relationship Among Wetland Vertical Development, Elevation Capital, Sea-Level Rise, and Tidal Marsh Sustainability. Estuaries and Coasts 42:1-15. https://doi.org/10.1007/s12237-018-0448-x  

Pinheiro J, Bates D, DebRoy S, Sarkar D, R Core Team. 2019. _nlme: Linear
and Nonlinear Mixed Effects Models_. R package version 3.1-140, 
https://CRAN.R-project.org/package=nlme  

Schenker, N. and J.F. Gentleman. 2001. On Judging the Significance of Differences by Examining the Overlap Between Confidence Intervals. The American Statistician 55(3):182-186. https://doi.org/10.1198/000313001317097960

Zuur, A.F., E.N. Ieno, N.J. Walker, A.A. Saveliev, and G.M. Smith. 2009. Mixed effects models and extensions in ecology with R. New York: Springer.  